import yara
import os
import concurrent.futures

def first_callback(data):
    if 'matches' in data:
        matches = data['matches']
        if isinstance(matches, list):  # Check if matches is a list
            for match in matches:
                if match.rule == 'my_first_rule' and all(key in match.strings for key in ['upx0', 'upx1', 'test', 'MZ_test']):
                    print(f"Matched rule '{match.rule}': The file matches criteria (UPX detected, contains 'notepad', starts with 'MZ')")
                elif match.rule == 'second_rule' and 'a' in match.strings:
                    print(f"Matched rule '{match.rule}': The file contains KERNEL32.")
        else:
            print("No matches found.")  # Handle case when matches is not a list
    else:
        print("No matches found.")

def detecting_yara(file_path, rule_path):
    if not os.path.exists(file_path):
        print(f"Error: File not found - {file_path}")
        return False

    if not os.path.exists(rule_path):
        print(f"Error: Rule file not found - {rule_path}")
        return False

    try:
        rules = yara.compile(rule_path)
        matches = rules.match(file_path, callback=first_callback)
        return matches is not None
    except Exception as e:
        print(f"Error: {e}")
        return False

if __name__ == "__main__":
    rule_path = "/home/kty1895/Desktop/new_rule.yar"
    file_paths = [
        "/home/kty1895/Desktop/Malicious Code sample/test_data/0a1332f55c43a59f751862555af5cb81918ebc8b3ec036e4f20107fcbcb61fb3.pdf",
        "/home/kty1895/Desktop/Malicious Code sample/test_data/0a01897c65dbab402d6dbb6b40b4c7e71fe45660b8f2099427f9bed41369ed51.pdf",
        "/home/kty1895/Desktop/Malicious Code sample/test_data/0a2386b951f4eb49af8a9df82f73b994d4ab77d9b2e837b82be13c6056decedc.pdf",
        "/home/kty1895/Desktop/Malicious Code sample/test_data/0a3447cae6da7e17736d1d4cf572d5b3981241fa7898a8bcdb0d70f3742e65f9.pdf",
        "/home/kty1895/Desktop/Malicious Code sample/test_data/0a4254f24556eadf0a5c95dc4aa54361a988a098482152e3bb13f1ef83df59fb.pdf",
        # Add more file paths here as needed
    ]

    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(detecting_yara, file_path, rule_path) for file_path in file_paths]

        for future, file_path in zip(concurrent.futures.as_completed(futures), file_paths):
            print(f"Analyzing file: {file_path}")
            if future.result():
                print("YARA rule matching completed.")
            else:
                print("YARA rule matching failed.")
            print()  # Add empty line for separation between file analyses
